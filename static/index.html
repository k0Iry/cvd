<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <title>CVD (Axum)</title>
    <style>
        body {
            margin: 0;
            background: #111;
            color: #ddd;
            font-family: sans-serif;
        }

        .bar {
            padding: 8px;
            display: flex;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid #222;
        }

        #wrap {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 46px);
        }

        #price {
            flex: 2;
        }

        #cvd {
            flex: 1;
            border-top: 1px solid #333;
        }

        select {
            background: #222;
            color: #ddd;
            border: 1px solid #444;
            padding: 4px 8px;
            border-radius: 6px;
        }

        .pill {
            font-size: 12px;
            padding: 2px 8px;
            border: 1px solid #333;
            border-radius: 999px;
        }
    </style>
</head>

<body>
    <div class="bar">
        <div class="pill">Source: local axum</div>

        <div>Symbol:</div>
        <select id="symbol">
            <option value="BTC">BTC</option>
            <option value="ETH">ETH</option>
            <option value="SOL">SOL</option>
            <option value="BNB">BNB</option>
            <option value="AAVE">AAVE</option>
        </select>

        <div>Market:</div>
        <select id="market">
            <option value="spot">spot</option>
            <option value="usdm">usdm</option>
            <option value="coinm">coinm</option>
        </select>

        <div>TF:</div>
        <select id="tf">
            <option value="1m">1m</option>
            <option value="5m">5m</option>
        </select>

        <div id="status" class="pill">loading…</div>
    </div>

    <div id="wrap">
        <div id="price"></div>
        <div id="cvd"></div>
    </div>

    <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
    <script>
        const symbolSel = document.getElementById("symbol");
        const marketSel = document.getElementById("market");
        const tfSel = document.getElementById("tf");
        const statusEl = document.getElementById("status");
        const priceEl = document.getElementById("price");
        const cvdEl = document.getElementById("cvd");

        function mkChart(el) {
            return LightweightCharts.createChart(el, {
                layout: { background: { color: "#111" }, textColor: "#ddd" },
                grid: { vertLines: { color: "#222" }, horzLines: { color: "#222" } },
                timeScale: {
                    borderColor: "#333",
                    timeVisible: true,
                    secondsVisible: false,
                    rightOffset: 2,
                },
                rightPriceScale: { borderColor: "#333" },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                width: el.clientWidth,
                height: el.clientHeight,
                handleScroll: { mouseWheel: true, pressedMouseMove: true, horzTouchDrag: true, vertTouchDrag: true },
                handleScale: { mouseWheel: true, pinch: true, axisPressedMouseMove: true },
            });
        }

        // 上：价格；下：CVD
        const priceChart = mkChart(priceEl);
        const cvdChart = mkChart(cvdEl);

        const priceSeries = priceChart.addLineSeries({
            lineWidth: 2,
            color: "#f2c94c",
            lastValueVisible: true,
            priceLineVisible: true,
        });

        const cvdSeries = cvdChart.addLineSeries({
            lineWidth: 2,
            color: "#56ccf2",
            priceFormat: {
                type: "custom",
                formatter: (p) => {
                    const abs = Math.abs(p);
                    if (abs >= 1e9) return (p / 1e9).toFixed(2) + "B";
                    if (abs >= 1e6) return (p / 1e6).toFixed(2) + "M";
                    if (abs >= 1e3) return (p / 1e3).toFixed(2) + "K";
                    return p.toFixed(0);
                },
            },
        });

        cvdChart.priceScale("right").applyOptions({ textColor: "#56ccf2", borderColor: "#333" });
        priceChart.priceScale("right").applyOptions({ textColor: "#f2c94c", borderColor: "#333" });

        function resize() {
            priceChart.applyOptions({ width: priceEl.clientWidth, height: priceEl.clientHeight });
            cvdChart.applyOptions({ width: cvdEl.clientWidth, height: cvdEl.clientHeight });
        }
        window.addEventListener("resize", resize);

        // ✅ timeScale 同步
        let syncing = false;
        function syncTimeScale(fromChart, toChart) {
            fromChart.timeScale().subscribeVisibleLogicalRangeChange((range) => {
                if (!range) return;
                if (syncing) return;
                syncing = true;
                toChart.timeScale().setVisibleLogicalRange(range);
                syncing = false;
            });
        }
        syncTimeScale(priceChart, cvdChart);
        syncTimeScale(cvdChart, priceChart);

        // ✅ crosshair 同步（保留你原版）
        function getSeriesPrice(param, series) {
            const sp = param && param.seriesPrices;
            if (!sp) return null;
            if (typeof sp.get === "function") {
                const v = sp.get(series);
                return typeof v === "number" ? v : null;
            }
            try {
                const v = sp[series];
                return typeof v === "number" ? v : null;
            } catch {
                return null;
            }
        }

        function syncCrosshair(srcChart, dstChart, srcSeries, dstSeries) {
            srcChart.subscribeCrosshairMove((param) => {
                if (!param || param.time === undefined) {
                    dstChart.clearCrosshairPosition();
                    return;
                }
                const price = getSeriesPrice(param, srcSeries);
                if (price == null) {
                    dstChart.setCrosshairPosition(NaN, param.time, dstSeries);
                } else {
                    dstChart.setCrosshairPosition(price, param.time, dstSeries);
                }
            });
        }
        syncCrosshair(priceChart, cvdChart, priceSeries, cvdSeries);
        syncCrosshair(cvdChart, priceChart, cvdSeries, priceSeries);

        // ---------------------------
        // 数据加载与 WS（带 retry）
        // ---------------------------
        let ws = null;

        // retry state
        let wsRetryTimer = null;
        let wsRetryAttempt = 0;

        // 当前想要的连接目标（避免旧连接回调污染）
        let wsWant = { symbol: null, market: null, tf: null };

        // 防乱序：记录最后一次更新时间
        let lastWsTime = 0;

        async function loadHistory(symbol, market, tf) {
            statusEl.textContent = "loading…";
            const res = await fetch(`/history?symbol=${encodeURIComponent(symbol)}&market=${encodeURIComponent(market)}&tf=${encodeURIComponent(tf)}&limit=800`);
            const bars = await res.json();

            priceSeries.setData(bars.map(b => ({ time: b.time, value: b.price_close })));
            cvdSeries.setData(bars.map(b => ({ time: b.time, value: b.cvd_usdt })));

            priceChart.timeScale().scrollToRealTime();
            statusEl.textContent = "live";
        }

        function connectWs(symbol, market, tf) {
            wsWant = { symbol, market, tf };
            lastWsTime = 0;

            // 取消待重连
            if (wsRetryTimer) {
                clearTimeout(wsRetryTimer);
                wsRetryTimer = null;
            }

            // 关闭旧连接（并断开旧回调）
            if (ws) {
                try { ws.onopen = ws.onclose = ws.onerror = ws.onmessage = null; } catch { }
                try { ws.close(); } catch { }
                ws = null;
            }

            const proto = location.protocol === "https:" ? "wss" : "ws";
            const url = `${proto}://${location.host}/ws?symbol=${encodeURIComponent(symbol)}&market=${encodeURIComponent(market)}&tf=${encodeURIComponent(tf)}`;

            statusEl.textContent = "connecting…";

            try {
                ws = new WebSocket(url);
            } catch (_) {
                scheduleReconnect(symbol, market, tf);
                return;
            }

            ws.onopen = async () => {
                if (wsWant.symbol !== symbol || wsWant.market !== market || wsWant.tf !== tf) {
                    try { ws.close(); } catch { }
                    return;
                }
                wsRetryAttempt = 0;
                statusEl.textContent = "live";

                // ✅ 重连成功后补一次 history（补齐断线期间 bar）
                try { await loadHistory(symbol, market, tf); } catch { }
            };

            ws.onclose = () => {
                if (wsWant.symbol !== symbol || wsWant.market !== market || wsWant.tf !== tf) return;
                statusEl.textContent = "disconnected";
                scheduleReconnect(symbol, market, tf);
            };

            ws.onerror = () => {
                // 避免 onerror + onclose 双 schedule（让 onclose 来做）
                if (wsWant.symbol !== symbol || wsWant.market !== market || wsWant.tf !== tf) return;
                statusEl.textContent = "error";
            };

            ws.onmessage = (ev) => {
                if (wsWant.symbol !== symbol || wsWant.market !== market || wsWant.tf !== tf) return;

                let b;
                try { b = JSON.parse(ev.data); } catch { return; }

                if (typeof b.time !== "number") return;
                if (b.time < lastWsTime) return;
                lastWsTime = b.time;

                if (typeof b.price_close === "number") {
                    priceSeries.update({ time: b.time, value: b.price_close });
                }
                if (typeof b.cvd_usdt === "number") {
                    cvdSeries.update({ time: b.time, value: b.cvd_usdt });
                }
            };
        }

        function scheduleReconnect(symbol, market, tf) {
            if (wsRetryTimer) return;

            wsRetryAttempt += 1;

            // 指数退避：0.5s, 1s, 2s, 4s, 8s... 上限 20s
            const base = Math.min(20000, 500 * Math.pow(2, Math.min(wsRetryAttempt, 6)));
            const jitter = Math.floor(Math.random() * 400);
            const delay = base + jitter;

            statusEl.textContent = `reconnect in ${(delay / 1000).toFixed(1)}s…`;

            wsRetryTimer = setTimeout(() => {
                wsRetryTimer = null;
                if (wsWant.symbol === symbol && wsWant.market === market && wsWant.tf === tf) {
                    connectWs(symbol, market, tf);
                }
            }, delay);
        }

        async function reload() {
            const symbol = symbolSel.value;
            const market = marketSel.value;
            const tf = tfSel.value;
            await loadHistory(symbol, market, tf);
            connectWs(symbol, market, tf);
        }

        symbolSel.addEventListener("change", reload);
        marketSel.addEventListener("change", reload);
        tfSel.addEventListener("change", reload);

        reload();
    </script>
</body>

</html>