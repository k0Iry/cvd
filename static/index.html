<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <title>CVD (Axum)</title>
    <style>
        body {
            margin: 0;
            background: #111;
            color: #ddd;
            font-family: sans-serif;
        }

        .bar {
            padding: 8px;
            display: flex;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid #222;
        }

        #wrap {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 46px);
        }

        #price {
            flex: 2;
        }

        #cvd {
            flex: 1;
            border-top: 1px solid #333;
        }

        select {
            background: #222;
            color: #ddd;
            border: 1px solid #444;
            padding: 4px 8px;
            border-radius: 6px;
        }

        .pill {
            font-size: 12px;
            padding: 2px 8px;
            border: 1px solid #333;
            border-radius: 999px;
        }
    </style>
</head>

<body>
    <div class="bar">
        <div class="pill">Source: local axum</div>

        <div>Market:</div>
        <select id="market">
            <option value="spot">spot</option>
            <option value="usdm">usdm</option>
            <option value="coinm">coinm</option>
        </select>

        <div>TF:</div>
        <select id="tf">
            <option value="1m">1m</option>
            <option value="5m">5m</option>
        </select>

        <div id="status" class="pill">loading…</div>
    </div>

    <div id="wrap">
        <div id="price"></div>
        <div id="cvd"></div>
    </div>

    <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
    <script>
        const marketSel = document.getElementById("market");
        const tfSel = document.getElementById("tf");
        const statusEl = document.getElementById("status");
        const priceEl = document.getElementById("price");
        const cvdEl = document.getElementById("cvd");

        function mkChart(el) {
            return LightweightCharts.createChart(el, {
                layout: { background: { color: "#111" }, textColor: "#ddd" },
                grid: { vertLines: { color: "#222" }, horzLines: { color: "#222" } },
                timeScale: {
                    borderColor: "#333",
                    timeVisible: true,
                    secondsVisible: false,
                    rightOffset: 2,
                },
                rightPriceScale: { borderColor: "#333" },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                width: el.clientWidth,
                height: el.clientHeight,
                // 允许滚轮/拖动缩放（横向）
                handleScroll: { mouseWheel: true, pressedMouseMove: true, horzTouchDrag: true, vertTouchDrag: true },
                handleScale: { mouseWheel: true, pinch: true, axisPressedMouseMove: true },
            });
        }

        // 上：价格；下：CVD
        const priceChart = mkChart(priceEl);
        const cvdChart = mkChart(cvdEl);

        // Price 线（右轴）
        const priceSeries = priceChart.addLineSeries({
            lineWidth: 2,
            color: "#f2c94c",
            lastValueVisible: true,
            priceLineVisible: true,
        });

        // CVD 线（右轴即可；你要左轴也可以，但一般下面 pane 用右轴更直观）
        const cvdSeries = cvdChart.addLineSeries({
            lineWidth: 2,
            color: "#56ccf2",
            priceFormat: {
                type: "custom",
                formatter: (p) => {
                    const abs = Math.abs(p);
                    if (abs >= 1e9) return (p / 1e9).toFixed(2) + "B";
                    if (abs >= 1e6) return (p / 1e6).toFixed(2) + "M";
                    if (abs >= 1e3) return (p / 1e3).toFixed(2) + "K";
                    return p.toFixed(0);
                },
            },
        });

        // 让下方 CVD 的右轴文字颜色和线一致
        cvdChart.priceScale("right").applyOptions({ textColor: "#56ccf2", borderColor: "#333" });
        priceChart.priceScale("right").applyOptions({ textColor: "#f2c94c", borderColor: "#333" });

        // resize
        function resize() {
            priceChart.applyOptions({ width: priceEl.clientWidth, height: priceEl.clientHeight });
            cvdChart.applyOptions({ width: cvdEl.clientWidth, height: cvdEl.clientHeight });
        }
        window.addEventListener("resize", resize);

        // ---------------------------
        // ✅ timeScale 同步（核心）
        // ---------------------------
        let syncing = false;

        function syncTimeScale(fromChart, toChart) {
            fromChart.timeScale().subscribeVisibleLogicalRangeChange((range) => {
                if (!range) return;
                if (syncing) return;
                syncing = true;
                toChart.timeScale().setVisibleLogicalRange(range);
                syncing = false;
            });
        }

        syncTimeScale(priceChart, cvdChart);
        syncTimeScale(cvdChart, priceChart);

        // ---------------------------
        // ✅ crosshair 同步（可选但非常爽）
        // ---------------------------
        function getSeriesPrice(param, series) {
            const sp = param && param.seriesPrices;
            if (!sp) return null;

            // Map-like
            if (typeof sp.get === "function") {
                const v = sp.get(series);
                return typeof v === "number" ? v : null;
            }

            // Object-like (rare, but guard anyway)
            try {
                const v = sp[series];
                return typeof v === "number" ? v : null;
            } catch {
                return null;
            }
        }

        function syncCrosshair(srcChart, dstChart, srcSeries, dstSeries) {
            srcChart.subscribeCrosshairMove((param) => {
                if (!param || param.time === undefined) {
                    dstChart.clearCrosshairPosition();
                    return;
                }

                const price = getSeriesPrice(param, srcSeries);

                // ✅ 不要 setCrosshairPosition(0, ...) —— 0 可能导致奇怪的 scale 行为
                if (price == null) {
                    dstChart.setCrosshairPosition(NaN, param.time, dstSeries);
                } else {
                    dstChart.setCrosshairPosition(price, param.time, dstSeries);
                }
            });
        }

        syncCrosshair(priceChart, cvdChart, priceSeries, cvdSeries);
        syncCrosshair(cvdChart, priceChart, cvdSeries, priceSeries);

        // 数据加载与 WS
        // ---------------------------
        let ws = null;

        // retry state
        let wsRetryTimer = null;
        let wsRetryAttempt = 0;

        // “我当前想要的连接目标”，用于避免旧连接回调污染
        let wsWant = { market: null, tf: null };

        // 防乱序：记录最后一次更新时间（每次 reload 会重置）
        let lastWsTime = 0;

        async function loadHistory(market, tf) {
            statusEl.textContent = "loading…";
            const res = await fetch(`/history?market=${market}&tf=${tf}&limit=800`);
            const bars = await res.json();

            priceSeries.setData(bars.map(b => ({ time: b.time, value: b.price_close })));
            cvdSeries.setData(bars.map(b => ({ time: b.time, value: b.cvd_usdt })));

            // 两张图都滚到最新（因为 timeScale 同步，滚一个也行）
            priceChart.timeScale().scrollToRealTime();
            statusEl.textContent = "live";
        }

        function connectWs(market, tf) {
            wsWant = { market, tf };
            lastWsTime = 0;

            // 取消待重连
            if (wsRetryTimer) {
                clearTimeout(wsRetryTimer);
                wsRetryTimer = null;
            }

            // 关闭旧连接（并断开旧回调）
            if (ws) {
                try { ws.onopen = ws.onclose = ws.onerror = ws.onmessage = null; } catch { }
                try { ws.close(); } catch { }
                ws = null;
            }

            const proto = location.protocol === "https:" ? "wss" : "ws";
            const url = `${proto}://${location.host}/ws?market=${market}&tf=${tf}`;

            statusEl.textContent = "connecting…";

            try {
                ws = new WebSocket(url);
            } catch (e) {
                scheduleReconnect(market, tf);
                return;
            }

            ws.onopen = async () => {
                // 如果用户已经切走了，立刻关掉这条连接
                if (wsWant.market !== market || wsWant.tf !== tf) {
                    try { ws.close(); } catch { }
                    return;
                }

                // ✅ 连上就清空退避计数
                wsRetryAttempt = 0;
                statusEl.textContent = "live";

                // ✅ 关键：重连成功后补一次 history（把断线期间的 bar 补齐）
                // 这一步会让公网偶发断线“几乎无感”
                try {
                    await loadHistory(market, tf);
                } catch (_) {
                    // ignore
                }
            };

            ws.onclose = () => {
                if (wsWant.market !== market || wsWant.tf !== tf) return;
                statusEl.textContent = "disconnected";
                scheduleReconnect(market, tf);
            };

            ws.onerror = () => {
                // 有些浏览器先 onerror 再 onclose；这里不 schedule，避免双触发
                if (wsWant.market !== market || wsWant.tf !== tf) return;
                statusEl.textContent = "error";
            };

            ws.onmessage = (ev) => {
                if (wsWant.market !== market || wsWant.tf !== tf) return;

                let b;
                try {
                    b = JSON.parse(ev.data);
                } catch {
                    return; // bad frame
                }

                // 防乱序：time 比上次小就丢弃（避免 chart update 抽风）
                if (typeof b.time !== "number") return;
                if (b.time < lastWsTime) return;
                lastWsTime = b.time;

                // 更新两张图（time 一样就会对齐）
                if (typeof b.price_close === "number") {
                    priceSeries.update({ time: b.time, value: b.price_close });
                }
                if (typeof b.cvd_usdt === "number") {
                    cvdSeries.update({ time: b.time, value: b.cvd_usdt });
                }
            };
        }

        function scheduleReconnect(market, tf) {
            if (wsRetryTimer) return;

            wsRetryAttempt += 1;

            // 指数退避：0.5s, 1s, 2s, 4s, 8s... 上限 20s
            const base = Math.min(20000, 500 * Math.pow(2, Math.min(wsRetryAttempt, 6)));
            const jitter = Math.floor(Math.random() * 400); // 0~400ms
            const delay = base + jitter;

            statusEl.textContent = `reconnect in ${(delay / 1000).toFixed(1)}s…`;

            wsRetryTimer = setTimeout(() => {
                wsRetryTimer = null;

                // 只有当前选择还没变才重连
                if (wsWant.market === market && wsWant.tf === tf) {
                    connectWs(market, tf);
                }
            }, delay);
        }

        async function reload() {
            const market = marketSel.value;
            const tf = tfSel.value;
            await loadHistory(market, tf);
            connectWs(market, tf);
        }

        marketSel.addEventListener("change", reload);
        tfSel.addEventListener("change", reload);

        reload();
    </script>
</body>

</html>