<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <title>CVD (Binance)</title>
    <style>
        body {
            margin: 0;
            background: #111;
            color: #ddd;
            font-family: sans-serif;
        }

        .bar {
            padding: 8px;
            display: flex;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid #222;
            flex-wrap: wrap;
        }

        #wrap {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 46px);
        }

        #price {
            flex: 2;
        }

        #cvd {
            flex: 1;
            border-top: 1px solid #333;
        }

        select {
            background: #222;
            color: #ddd;
            border: 1px solid #444;
            padding: 4px 8px;
            border-radius: 6px;
        }

        .pill {
            font-size: 12px;
            padding: 2px 8px;
            border: 1px solid #333;
            border-radius: 999px;
        }
    </style>
</head>

<body>
    <div class="bar">
        <div class="pill">Source: local axum</div>

        <div>Exchange:</div>
        <select id="exchange">
            <option value="binance" selected>Binance</option>
            <option value="coinbase">Coinbase</option>
        </select>

        <div>Symbol:</div>
        <select id="symbol">
            <option>BTC</option>
            <option>ETH</option>
            <option>SOL</option>
            <option>BNB</option>
            <option>AAVE</option>
        </select>

        <div>Market:</div>
        <select id="market">
            <option>spot</option>
            <option>usdm</option>
            <option>coinm</option>
        </select>

        <div>TF:</div>
        <select id="tf">
            <option>1m</option>
            <option>5m</option>
        </select>

        <div>Timezone:</div>
        <select id="tz">
            <option value="local">Local</option>
            <option value="UTC">UTC</option>
            <option value="Asia/Shanghai">Beijing</option>
            <option value="America/New_York">New York</option>
            <option value="Europe/London">London</option>
        </select>

        <button id="shotAll">üì∏ Screenshot</button>

        <div id="status" class="pill">loading‚Ä¶</div>
    </div>

    <div id="wrap">
        <div id="price"></div>
        <div id="cvd"></div>
    </div>

    <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
    <script>
        const exchangeSel = document.getElementById("exchange");
        const symbolSel = document.getElementById("symbol");
        const marketSel = document.getElementById("market");
        const tfSel = document.getElementById("tf");
        const tzSel = document.getElementById("tz");
        const statusEl = document.getElementById("status");

        const API = "";

        // Coinbase only supports Spot market and BTC/ETH
        function updateMarketOptions() {
            const exchange = exchangeSel.value;
            const currentMarket = marketSel.value;
            
            if (exchange === "coinbase") {
                // Coinbase only supports Spot
                marketSel.innerHTML = '<option>spot</option>';
                if (currentMarket !== "spot") marketSel.value = "spot";
                
                // Limit symbols to BTC and ETH
                const currentSymbol = symbolSel.value;
                symbolSel.innerHTML = '<option>BTC</option><option>ETH</option>';
                if (currentSymbol !== "BTC" && currentSymbol !== "ETH") symbolSel.value = "BTC";
            } else {
                // Binance supports all
                marketSel.innerHTML = '<option>spot</option><option>usdm</option><option>coinm</option>';
                symbolSel.innerHTML = '<option>BTC</option><option>ETH</option><option>SOL</option><option>BNB</option><option>AAVE</option>';
            }
        }

        exchangeSel.onchange = () => {
            updateMarketOptions();
            reload();
        };

        function mkChart(el) {
            return LightweightCharts.createChart(el, {
                layout: { background: { color: "#111" }, textColor: "#ddd" },
                grid: { vertLines: { color: "#222" }, horzLines: { color: "#222" } },
                timeScale: {
                    borderColor: "#333",
                    rightOffset: 2,
                    timeVisible: true,
                    secondsVisible: false,
                },
                rightPriceScale: { borderColor: "#333" },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                width: el.clientWidth, height: el.clientHeight
            });
        }

        const priceEl = document.getElementById("price");
        const cvdEl = document.getElementById("cvd");
        const priceChart = mkChart(priceEl);
        const cvdChart = mkChart(cvdEl);

        const priceSeries = priceChart.addLineSeries({ color: "#f2c94c", lineWidth: 2 });
        const cvdSeries = cvdChart.addLineSeries({
            color: "#56ccf2",
            lineWidth: 2,
            priceFormat: {
                type: "custom",
                formatter: (p) => {
                    const a = Math.abs(p);
                    if (a >= 1e9) return (p / 1e9).toFixed(2) + "B";
                    if (a >= 1e6) return (p / 1e6).toFixed(2) + "M";
                    if (a >= 1e3) return (p / 1e3).toFixed(2) + "K";
                    return p.toFixed(0);
                }
            }
        });

        function resize() {
            priceChart.applyOptions({ width: priceEl.clientWidth, height: priceEl.clientHeight });
            cvdChart.applyOptions({ width: cvdEl.clientWidth, height: cvdEl.clientHeight });
        }
        window.addEventListener("resize", resize);

        /* ---------- timeScale ÂêåÊ≠•ÔºàÁ®≥ÂÆöÁâàÔºâ ---------- */
        let syncing = false;
        function sync(a, b) {
            a.timeScale().subscribeVisibleLogicalRangeChange(r => {
                if (!r || syncing) return;
                syncing = true; b.timeScale().setVisibleLogicalRange(r); syncing = false;
            });
        }
        sync(priceChart, cvdChart);
        sync(cvdChart, priceChart);

        /* ---------- Êó∂Âå∫ + ÂàÜÈíüÂàªÂ∫¶ ---------- */
        let currentTz = tzSel.value;

        function formatTime(sec) {
            return new Intl.DateTimeFormat("en-GB", {
                timeZone: currentTz === "local" ? undefined : currentTz,
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
            }).format(new Date(sec * 1000));
        }

        function applyTz(chart) {
            chart.applyOptions({
                timeScale: { tickMarkFormatter: (t) => (typeof t === "number" ? formatTime(t) : "") }
            });
        }

        applyTz(priceChart);
        applyTz(cvdChart);

        tzSel.onchange = () => {
            currentTz = tzSel.value;
            applyTz(priceChart);
            applyTz(cvdChart);
        };

        /* ---------- paging + in-memory ---------- */
        const page = {
            bars: [],
            oldestTime: null,
            loadingMore: false,
            reachedStart: false,
            pageSize: 800,
            maxKeep: 4000,
            lastKey: "",
        };

        function setBars(bars, keepRange = null) {
            page.bars = bars;
            page.oldestTime = bars.length ? bars[0].time : null;

            priceSeries.setData(bars.map(b => ({ time: b.time, value: b.price_close })));
            cvdSeries.setData(bars.map(b => ({ time: b.time, value: b.cvd_usdt })));

            if (keepRange) {
                priceChart.timeScale().setVisibleLogicalRange(keepRange);
            }
        }

        function mergePrepend(currentBars, olderBars) {
            if (!olderBars || olderBars.length === 0) return currentBars;
            const curFirst = currentBars.length ? currentBars[0].time : null;
            const filteredOlder = (curFirst == null) ? olderBars : olderBars.filter(b => b.time < curFirst);
            const merged = [...filteredOlder, ...currentBars];
            if (merged.length > page.maxKeep) return merged.slice(merged.length - page.maxKeep);
            return merged;
        }

        async function fetchHistory(exchange, symbol, market, tf, limit, before) {
            const u = new URL(`${API}/history`, location.origin);
            u.searchParams.set("exchange", exchange);
            u.searchParams.set("symbol", symbol);
            u.searchParams.set("market", market);
            u.searchParams.set("tf", tf);
            u.searchParams.set("limit", String(limit));
            if (before != null) u.searchParams.set("before", String(before));
            const r = await fetch(u);
            return r.ok ? r.json() : [];
        }

        async function loadInitial(exchange, symbol, market, tf) {
            statusEl.textContent = "loading‚Ä¶";
            page.loadingMore = false;
            page.reachedStart = false;

            const bars = await fetchHistory(exchange, symbol, market, tf, page.pageSize, null);
            setBars(Array.isArray(bars) ? bars : []);
            priceChart.timeScale().scrollToRealTime();
            statusEl.textContent = "live";
        }

        async function loadMoreBefore(exchange, symbol, market, tf) {
            if (page.loadingMore || page.reachedStart) return;
            if (!page.bars.length || page.oldestTime == null) return;

            page.loadingMore = true;

            const oldRange = priceChart.timeScale().getVisibleLogicalRange();
            const oldLen = page.bars.length;

            try {
                const older = await fetchHistory(exchange, symbol, market, tf, page.pageSize, page.oldestTime);
                const olderBars = Array.isArray(older) ? older : [];
                if (!olderBars.length) { page.reachedStart = true; return; }

                const merged = mergePrepend(page.bars, olderBars);
                setBars(merged);

                if (oldRange) {
                    const delta = merged.length - oldLen;
                    priceChart.timeScale().setVisibleLogicalRange({
                        from: oldRange.from + delta,
                        to: oldRange.to + delta,
                    });
                }
            } finally {
                page.loadingMore = false;
            }
        }

        // ÊãñÂà∞ÊúÄÂ∑¶ËæπÈôÑËøëÂ∞±ÁøªÈ°µ
        priceChart.timeScale().subscribeVisibleLogicalRangeChange((r) => {
            if (!r) return;
            if (r.from <= 30) {
                loadMoreBefore(exchangeSel.value, symbolSel.value, marketSel.value, tfSel.value);
            }
        });

        /* ---------- websocket ---------- */
        let ws = null;
        let wsWant = {};
        let lastWsTime = 0;

        function connectWs(exchange, symbol, market, tf) {
            wsWant = { exchange, symbol, market, tf };
            lastWsTime = 0;

            if (ws) { try { ws.onopen = ws.onclose = ws.onmessage = ws.onerror = null; ws.close(); } catch { }; ws = null; }

            const proto = location.protocol === "https:" ? "wss" : "ws";
            ws = new WebSocket(`${proto}://${location.host}${API}/ws?exchange=${exchange}&symbol=${symbol}&market=${market}&tf=${tf}`);
            statusEl.textContent = "connecting‚Ä¶";

            ws.onopen = () => statusEl.textContent = "live";

            ws.onmessage = (ev) => {
                if (wsWant.exchange !== exchange || wsWant.symbol !== symbol || wsWant.market !== market || wsWant.tf !== tf) return;

                let b;
                try { b = JSON.parse(ev.data); } catch { return; }
                if (typeof b.time !== "number") return;

                // Ê≥®ÊÑèÔºöËøôÈáå‰øùÊåÅ‰Ω†ÂéüÈÄªËæëÔºö<= Â∞±‰∏¢ÔºàÈÅøÂÖç‰π±Â∫è/ÂõûÊîæÔºâ
                if (b.time < lastWsTime) return;
                lastWsTime = b.time;

                const bars = page.bars;
                const last = bars[bars.length - 1];

                if (last && last.time === b.time) {
                    bars[bars.length - 1] = b;
                } else if (!last || b.time > last.time) {
                    bars.push(b);
                    if (bars.length > page.maxKeep) bars.shift();
                }

                // ‚úÖ Âè™ updateÔºå‰∏ç setData
                if (typeof b.price_close === "number") priceSeries.update({ time: b.time, value: b.price_close });
                if (typeof b.cvd_usdt === "number") cvdSeries.update({ time: b.time, value: b.cvd_usdt });

                page.oldestTime = bars.length ? bars[0].time : null;
            };

            ws.onclose = () => statusEl.textContent = "disconnected";
        }

        /* ---------- reload ---------- */
        async function reload() {
            const e = exchangeSel.value, s = symbolSel.value, m = marketSel.value, tf = tfSel.value;
            const key = `${e}|${s}|${m}|${tf}`;
            if (page.lastKey !== key) {
                page.lastKey = key;
                page.bars = [];
                page.oldestTime = null;
                page.loadingMore = false;
                page.reachedStart = false;
            }
            await loadInitial(e, s, m, tf);
            connectWs(e, s, m, tf);
        }

        symbolSel.onchange = reload;
        marketSel.onchange = reload;
        tfSel.onchange = reload;

        // Initialize market options and reload
        updateMarketOptions();
        reload();

        /* ---------- screenshot (ÊñπÊ°à BÔºöÂêàÊàê‰∏ÄÂº†) ---------- */
        function screenshotBoth() {
            const c1 = priceChart.takeScreenshot();
            const c2 = cvdChart.takeScreenshot();

            const w = Math.max(c1.width, c2.width);
            const h = c1.height + c2.height;

            const out = document.createElement("canvas");
            out.width = w;
            out.height = h;

            const ctx = out.getContext("2d");
            // ËÉåÊôØËâ≤ÔºåÈÅøÂÖçÈÄèÊòé
            ctx.fillStyle = "#111";
            ctx.fillRect(0, 0, w, h);

            ctx.drawImage(c1, 0, 0);
            ctx.drawImage(c2, 0, c1.height);

            const a = document.createElement("a");
            a.download = `cvd_${exchangeSel.value}_${symbolSel.value}_${marketSel.value}_${tfSel.value}.png`;
            a.href = out.toDataURL("image/png");
            a.click();
        }

        document.getElementById("shotAll").onclick = screenshotBoth;
    </script>
</body>

</html>