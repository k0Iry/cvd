<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CVD</title>

    <style>
        body {
            margin: 0;
            background: #111;
            color: #ddd;
            font-family: sans-serif
        }

        .bar {
            padding: 8px;
            display: flex;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid #222;
            flex-wrap: wrap
        }

        #wrap {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 46px)
        }

        #price {
            flex: 2
        }

        #cvd {
            flex: 1;
            border-top: 1px solid #333
        }

        select {
            background: #222;
            color: #ddd;
            border: 1px solid #444;
            padding: 4px 8px;
            border-radius: 6px
        }

        .pill {
            font-size: 12px;
            padding: 2px 8px;
            border: 1px solid #333;
            border-radius: 999px
        }
    </style>
</head>

<body>

    <div class="bar">
        <div class="pill">Source: local axum</div>

        <div>Exchange:</div>
        <select id="exchange">
            <option value="binance">Binance</option>
            <option value="coinbase">Coinbase</option>
        </select>

        <div>Symbol:</div>
        <select id="symbol">
            <option>BTC</option>
            <option>ETH</option>
            <option>SOL</option>
            <option>BNB</option>
            <option>AAVE</option>
        </select>

        <div>Market:</div>
        <select id="market">
            <option>spot</option>
            <option>usdm</option>
            <option>coinm</option>
        </select>

        <div>TF:</div>
        <select id="tf">
            <option>1m</option>
            <option>5m</option>
        </select>

        <button id="shotAll">ðŸ“¸ Screenshot</button>
        <div id="status" class="pill">loadingâ€¦</div>
    </div>

    <div id="wrap">
        <div id="price"></div>
        <div id="cvd"></div>
    </div>

    <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>

    <script>

        const CONFIG = {
            HISTORY_PAGE_SIZE: 800,
            WINDOW_SIZE: 20000,
            EDGE_TRIGGER: 30
        }

        const exchangeSel = document.getElementById("exchange")
        const symbolSel = document.getElementById("symbol")
        const marketSel = document.getElementById("market")
        const tfSel = document.getElementById("tf")
        const statusEl = document.getElementById("status")

        const priceChart = LightweightCharts.createChart(document.getElementById("price"), {
            layout: { background: { color: "#111" }, textColor: "#ddd" },
            grid: { vertLines: { color: "#222" }, horzLines: { color: "#222" } },
            timeScale: { borderColor: "#333" },
            rightPriceScale: { borderColor: "#333" }
        })

        const cvdChart = LightweightCharts.createChart(document.getElementById("cvd"), {
            layout: { background: { color: "#111" }, textColor: "#ddd" },
            grid: { vertLines: { color: "#222" }, horzLines: { color: "#222" } },
            timeScale: { borderColor: "#333" },
            rightPriceScale: { borderColor: "#333" }
        })

        const priceSeries = priceChart.addLineSeries({ color: "#f2c94c" })
        const cvdSeries = cvdChart.addLineSeries({ color: "#56ccf2" })

        let programmaticRangeChange = false
        let syncing = false
        let lastAfterFetchAt = 0
        let lastBeforeFetchAt = 0

        function sync(a, b) {
            a.timeScale().subscribeVisibleLogicalRangeChange(r => {
                if (programmaticRangeChange) return
                if (!r || syncing) return
                syncing = true
                b.timeScale().setVisibleLogicalRange(r)
                syncing = false
            })
        }

        sync(priceChart, cvdChart)
        sync(cvdChart, priceChart)

        const page = {
            bars: [],
            oldestTime: null,
            newestTime: null,
            loadingOlder: false,
            loadingNewer: false,
            reachedStart: false,
            reachedEnd: false
        }

        function setBars(bars, keepRange = null) {
            programmaticRangeChange = true
            page.bars = bars
            page.oldestTime = bars[0]?.time ?? null
            page.newestTime = bars[bars.length - 1]?.time ?? null

            priceSeries.setData(bars.map(b => ({ time: b.time, value: b.price_close })))
            cvdSeries.setData(bars.map(b => ({ time: b.time, value: b.cvd_usdt })))

            if (keepRange) priceChart.timeScale().setVisibleLogicalRange(keepRange)

            requestAnimationFrame(() => programmaticRangeChange = false)
        }

        function trimToWindow(bars, oldRange) {
            if (bars.length <= CONFIG.WINDOW_SIZE) return { bars, newRange: oldRange }
            const start = bars.length - CONFIG.WINDOW_SIZE
            const sliced = bars.slice(start)
            let newRange = oldRange
            if (oldRange) {
                newRange = { from: oldRange.from - start, to: oldRange.to - start }
            }
            return { bars: sliced, newRange }
        }

        async function fetchHistory(exchange, symbol, market, tf, limit, before = null, after = null) {
            const u = new URL("/history", location.origin)
            u.searchParams.set("exchange", exchange)
            u.searchParams.set("symbol", symbol)
            u.searchParams.set("market", market)
            u.searchParams.set("tf", tf)
            u.searchParams.set("limit", limit)
            if (before != null) u.searchParams.set("before", before)
            if (after != null) u.searchParams.set("after", after)
            const r = await fetch(u)
            return r.ok ? await r.json() : []
        }

        async function loadInitial() {
            const bars = await fetchHistory(exchangeSel.value, symbolSel.value, marketSel.value, tfSel.value, CONFIG.HISTORY_PAGE_SIZE)
            setBars(bars || [])
        }

        async function loadMoreBefore() {
            if (page.loadingOlder || page.reachedStart) return
            if (!page.oldestTime) return

            const now = Date.now()
            if (now - lastBeforeFetchAt < 300) return
            lastBeforeFetchAt = now

            page.loadingOlder = true
            const oldRange = priceChart.timeScale().getVisibleLogicalRange()

            try {
                const older = await fetchHistory(exchangeSel.value, symbolSel.value, marketSel.value, tfSel.value, CONFIG.HISTORY_PAGE_SIZE, page.oldestTime, null)
                if (!older.length) { page.reachedStart = true; return }
                const merged = [...older.filter(b => b.time < page.oldestTime), ...page.bars]
                const trimmed = trimToWindow(merged, oldRange)
                setBars(trimmed.bars, trimmed.newRange)
            }
            finally { page.loadingOlder = false }
        }

        async function loadMoreAfter() {
            if (page.loadingNewer || page.reachedEnd) return
            if (!page.newestTime) return

            const now = Date.now()
            if (now - lastAfterFetchAt < 300) return
            lastAfterFetchAt = now

            page.loadingNewer = true
            const oldRange = priceChart.timeScale().getVisibleLogicalRange()

            try {
                const newer = await fetchHistory(exchangeSel.value, symbolSel.value, marketSel.value, tfSel.value, CONFIG.HISTORY_PAGE_SIZE, null, page.newestTime)
                if (!newer.length) { page.reachedEnd = true; return }
                const merged = [...page.bars, ...newer.filter(b => b.time > page.newestTime)]
                const trimmed = trimToWindow(merged, oldRange)
                setBars(trimmed.bars, trimmed.newRange)
            }
            finally { page.loadingNewer = false }
        }

        priceChart.timeScale().subscribeVisibleLogicalRangeChange(r => {
            if (programmaticRangeChange) return
            if (!r || !page.bars.length) return

            if (r.from <= CONFIG.EDGE_TRIGGER) loadMoreBefore()

            const maxIndex = page.bars.length - 1
            const rightIndex = Math.min(r.to, maxIndex)
            const rightGap = maxIndex - rightIndex

            if (rightGap <= CONFIG.EDGE_TRIGGER) loadMoreAfter()
        })

        loadInitial()

    </script>
</body>

</html>