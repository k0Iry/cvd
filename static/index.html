<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>CVD</title>
    <style>
        body {
            margin: 0;
            background: #111;
            color: #ddd;
            font-family: sans-serif;
        }

        .bar {
            padding: 8px;
            display: flex;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid #222;
            flex-wrap: wrap;
        }

        #wrap {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 46px);
        }

        #price {
            flex: 2;
        }

        #cvd {
            flex: 1;
            border-top: 1px solid #333;
        }

        select {
            background: #222;
            color: #ddd;
            border: 1px solid #444;
            padding: 4px 8px;
            border-radius: 6px;
        }

        .pill {
            font-size: 12px;
            padding: 2px 8px;
            border: 1px solid #333;
            border-radius: 999px;
        }
    </style>
</head>

<body>
    <div class="bar">
        <div class="pill">Source: local axum</div>

        <div>Exchange:</div>
        <select id="exchange">
            <option value="binance" selected>Binance</option>
            <option value="coinbase">Coinbase</option>
        </select>

        <div>Symbol:</div>
        <select id="symbol">
            <option>BTC</option>
            <option>ETH</option>
            <option>SOL</option>
            <option>BNB</option>
            <option>AAVE</option>
        </select>

        <div>Market:</div>
        <select id="market">
            <option>spot</option>
            <option>usdm</option>
            <option>coinm</option>
        </select>

        <div>TF:</div>
        <select id="tf">
            <option>1m</option>
            <option>5m</option>
        </select>

        <div>Timezone:</div>
        <select id="tz">
            <option value="local">Local</option>
            <option value="UTC">UTC</option>
            <option value="Asia/Shanghai">Beijing</option>
            <option value="America/New_York">New York</option>
            <option value="Europe/London">London</option>
        </select>

        <button id="shotAll">üì∏ Screenshot</button>

        <div id="status" class="pill">loading‚Ä¶</div>
    </div>

    <div id="wrap">
        <div id="price"></div>
        <div id="cvd"></div>
    </div>

    <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
    <script>
        // ==================== CONFIG ====================
        const CONFIG = {
            HISTORY_PAGE_SIZE: 800,
            MAX_CACHED_BARS: 4000,
            LOAD_TRIGGER: 30, // bars from left edge
            WS_RECONNECT_DELAY: 3000, // ms
            WS_MAX_RECONNECT_ATTEMPTS: 10,
            FETCH_TIMEOUT: 10000, // ms
            STORAGE_KEY_PREFIX: 'cvd_',
        };

        // ==================== EXCHANGE/MARKET CONFIG ====================
        const EXCHANGE_CONFIG = {
            binance: {
                markets: ['spot', 'usdm', 'coinm'],
                symbols: ['BTC', 'ETH', 'SOL', 'BNB', 'AAVE'],
            },
            coinbase: {
                markets: ['spot'],
                symbols: ['BTC', 'ETH'],
            },
        };

        // ==================== DOM ELEMENTS ====================
        const exchangeSel = document.getElementById("exchange");
        const symbolSel = document.getElementById("symbol");
        const marketSel = document.getElementById("market");
        const tfSel = document.getElementById("tf");
        const tzSel = document.getElementById("tz");
        const statusEl = document.getElementById("status");

        const API = "";

        // Update market/symbol options based on selected exchange
        function updateMarketOptions() {
            const exchange = exchangeSel.value;
            const config = EXCHANGE_CONFIG[exchange];
            if (!config) return;

            const currentMarket = marketSel.value;
            const currentSymbol = symbolSel.value;

            // Update markets
            marketSel.innerHTML = config.markets.map(m => `<option>${m}</option>`).join('');
            if (!currentMarket || !config.markets.includes(currentMarket)) {
                marketSel.value = config.markets[0];
            } else {
                marketSel.value = currentMarket;
            }

            // Update symbols
            symbolSel.innerHTML = config.symbols.map(s => `<option>${s}</option>`).join('');
            if (!currentSymbol || !config.symbols.includes(currentSymbol)) {
                symbolSel.value = config.symbols[0];
            } else {
                symbolSel.value = currentSymbol;
            }
        }

        exchangeSel.onchange = () => {
            updateMarketOptions();
            reload();
        };

        function mkChart(el) {
            return LightweightCharts.createChart(el, {
                layout: { background: { color: "#111" }, textColor: "#ddd" },
                grid: { vertLines: { color: "#222" }, horzLines: { color: "#222" } },
                timeScale: {
                    borderColor: "#333",
                    rightOffset: 2,
                    timeVisible: true,
                    secondsVisible: false,
                },
                rightPriceScale: { borderColor: "#333" },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                width: el.clientWidth, height: el.clientHeight
            });
        }

        // ==================== CHARTS ====================
        const priceEl = document.getElementById("price");
        const cvdEl = document.getElementById("cvd");
        const priceChart = mkChart(priceEl);
        const cvdChart = mkChart(cvdEl);

        const priceSeries = priceChart.addLineSeries({
            color: "#f2c94c",
            lineWidth: 2,
            priceLineVisible: true,
        });
        const cvdSeries = cvdChart.addLineSeries({
            color: "#56ccf2",
            lineWidth: 2,
            priceFormat: {
                type: "custom",
                formatter: (p) => {
                    const a = Math.abs(p);
                    if (a >= 1e9) return (p / 1e9).toFixed(2) + "B";
                    if (a >= 1e6) return (p / 1e6).toFixed(2) + "M";
                    if (a >= 1e3) return (p / 1e3).toFixed(2) + "K";
                    return p.toFixed(0);
                }
            }
        });

        function resize() {
            priceChart.applyOptions({ width: priceEl.clientWidth, height: priceEl.clientHeight });
            cvdChart.applyOptions({ width: cvdEl.clientWidth, height: cvdEl.clientHeight });
        }
        window.addEventListener("resize", resize);

        /* ---------- timeScale ÂêåÊ≠•ÔºàÁ®≥ÂÆöÁâàÔºâ ---------- */
        let syncing = false;
        function sync(a, b) {
            a.timeScale().subscribeVisibleLogicalRangeChange(r => {
                if (!r || syncing) return;
                syncing = true; b.timeScale().setVisibleLogicalRange(r); syncing = false;
            });
        }
        sync(priceChart, cvdChart);
        sync(cvdChart, priceChart);

        /* ---------- Êó∂Âå∫ + ÂàÜÈíüÂàªÂ∫¶ ---------- */
        let currentTz = tzSel.value;

        function formatTime(sec) {
            return new Intl.DateTimeFormat("en-GB", {
                timeZone: currentTz === "local" ? undefined : currentTz,
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
            }).format(new Date(sec * 1000));
        }

        function applyTz(chart) {
            chart.applyOptions({
                timeScale: { tickMarkFormatter: (t) => (typeof t === "number" ? formatTime(t) : "") }
            });
        }

        applyTz(priceChart);
        applyTz(cvdChart);

        /* ---------- paging + in-memory ---------- */
        // Page state
        const page = {
            bars: [],
            oldestTime: null,
            loadingMore: false,
            reachedStart: false,
            lastKey: "",
        };

        // ======== AUTO-FOLLOW (no button) ========
        let isFollowing = true;           // start in follow mode
        let programmaticScroll = false;   // prevent feedback loop
        const FOLLOW_RIGHT_BARS = 5;      // "how close to right edge counts as live"

        // Âà§Êñ≠ÂΩìÂâçËßÜÁ™óÊòØÂê¶Â∑≤ÁªèË¥¥ËøëÊúÄÂè≥‰æß
        function isNearRightEdge(chart) {
            const r = chart.timeScale().getVisibleLogicalRange();
            if (!r || !page.bars.length) return true;

            // logical index roughly maps to data index (0..len-1)
            const rightMostIdx = page.bars.length - 1;
            return (rightMostIdx - r.to) <= FOLLOW_RIGHT_BARS;
        }

        // Âè™Ë¶ÅÁî®Êà∑ÊääÂõæÊãñÂõûÂè≥ËæπÔºåÂ∞±Ëá™Âä®ÊÅ¢Â§ç follow
        priceChart.timeScale().subscribeVisibleLogicalRangeChange((r) => {
            if (!r || programmaticScroll) return;

            // Áî®Êà∑Âú®Êìç‰ΩúÂØºËá¥ÁöÑ range changeÔºöÂà§Êñ≠ÊòØÂê¶ÂõûÂà∞‰∫ÜÂè≥Ëæπ
            const nearRight = isNearRightEdge(priceChart);
            isFollowing = nearRight;
        });

        function setBars(bars, keepRange = null) {
            page.bars = bars;
            page.oldestTime = bars.length ? bars[0].time : null;

            priceSeries.setData(bars.map(b => ({ time: b.time, value: b.price_close })));
            cvdSeries.setData(bars.map(b => ({ time: b.time, value: b.cvd_usdt })));

            if (keepRange) {
                priceChart.timeScale().setVisibleLogicalRange(keepRange);
            }
        }

        function mergePrepend(currentBars, olderBars) {
            if (!olderBars || olderBars.length === 0) return currentBars;

            const curFirst = currentBars.length ? currentBars[0].time : null;
            const filteredOlder = (curFirst == null)
                ? olderBars
                : olderBars.filter(b => b.time < curFirst);

            const merged = [...filteredOlder, ...currentBars];

            // Âè™ÊúâÂú®ÂÆûÊó∂Ê®°Âºè‰∏ãÊâçÈôêÂà∂ÂÆπÈáè
            if (isFollowing && merged.length > CONFIG.MAX_CACHED_BARS) {
                return merged.slice(merged.length - CONFIG.MAX_CACHED_BARS);
            }

            return merged;
        }

        // Fetch history with timeout and error handling
        async function fetchHistory(exchange, symbol, market, tf, limit, before) {
            const u = new URL(`${API}/history`, location.origin);
            u.searchParams.set("exchange", exchange);
            u.searchParams.set("symbol", symbol);
            u.searchParams.set("market", market);
            u.searchParams.set("tf", tf);
            u.searchParams.set("limit", String(limit));
            if (before != null) u.searchParams.set("before", String(before));

            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), CONFIG.FETCH_TIMEOUT);
                const r = await fetch(u, { signal: controller.signal });
                clearTimeout(timeout);
                return r.ok ? await r.json() : [];
            } catch (err) {
                console.warn('Fetch error:', err.message);
                return [];
            }
        }

        async function loadInitial(exchange, symbol, market, tf) {
            statusEl.textContent = "loading‚Ä¶";
            page.loadingMore = false;
            page.reachedStart = false;

            const bars = await fetchHistory(exchange, symbol, market, tf, CONFIG.HISTORY_PAGE_SIZE, null);
            setBars(Array.isArray(bars) ? bars : []);

            isFollowing = true;

            priceChart.timeScale().scrollToRealTime();
            statusEl.textContent = "live";
        }

        async function loadMoreBefore(exchange, symbol, market, tf) {
            if (page.loadingMore || page.reachedStart) return;
            if (!page.bars.length || page.oldestTime == null) return;

            page.loadingMore = true;

            const oldRange = priceChart.timeScale().getVisibleLogicalRange();
            const oldLen = page.bars.length;

            try {
                const older = await fetchHistory(exchange, symbol, market, tf, CONFIG.HISTORY_PAGE_SIZE, page.oldestTime);
                const olderBars = Array.isArray(older) ? older : [];
                if (!olderBars.length) { page.reachedStart = true; return; }

                const merged = mergePrepend(page.bars, olderBars);
                setBars(merged);

                if (oldRange) {
                    const delta = merged.length - oldLen;
                    priceChart.timeScale().setVisibleLogicalRange({
                        from: oldRange.from + delta,
                        to: oldRange.to + delta,
                    });
                }
            } finally {
                page.loadingMore = false;
            }
        }

        // Load more bars when scrolling to the left edge
        priceChart.timeScale().subscribeVisibleLogicalRangeChange((r) => {
            if (!r) return;
            if (r.from <= CONFIG.LOAD_TRIGGER) {
                loadMoreBefore(exchangeSel.value, symbolSel.value, marketSel.value, tfSel.value);
            }
        });

        // ==================== WEBSOCKET ====================
        let ws = null;
        let wsWant = {};
        let lastWsTime = 0;
        let wsReconnectAttempts = 0;
        let wsReconnectTimeout = null;

        function closeWs() {
            if (ws) {
                try {
                    ws.onopen = ws.onclose = ws.onmessage = ws.onerror = null;
                    ws.close();
                } catch { }
                ws = null;
            }
            if (wsReconnectTimeout) clearTimeout(wsReconnectTimeout);
        }

        function connectWs(exchange, symbol, market, tf) {
            const wantKey = `${exchange}|${symbol}|${market}|${tf}`;
            if (wsWant.key === wantKey && ws && ws.readyState === WebSocket.OPEN) {
                return; // Already connected
            }

            wsWant = { exchange, symbol, market, tf, key: wantKey };
            lastWsTime = 0;
            wsReconnectAttempts = 0;

            closeWs();

            const proto = location.protocol === "https:" ? "wss" : "ws";
            ws = new WebSocket(`${proto}://${location.host}${API}/ws?exchange=${exchange}&symbol=${symbol}&market=${market}&tf=${tf}`);
            statusEl.textContent = "connecting‚Ä¶";

            ws.onopen = () => {
                wsReconnectAttempts = 0;
                statusEl.textContent = "live";
            };

            ws.onmessage = (ev) => {
                if (wsWant.key !== wantKey) return; // Ignore if no longer wanted

                let b;
                try {
                    b = JSON.parse(ev.data);
                } catch (err) {
                    console.warn('JSON parse error:', err.message);
                    return;
                }
                if (typeof b.time !== "number") return;

                if (b.time < lastWsTime) return; // Ignore out-of-order messages
                lastWsTime = b.time;

                const bars = page.bars;
                const last = bars[bars.length - 1];

                if (last && last.time === b.time) {
                    bars[bars.length - 1] = b; // Update existing
                } else if (!last || b.time > last.time) {
                    bars.push(b); // Append new
                    if (isFollowing && bars.length > CONFIG.MAX_CACHED_BARS) bars.shift();
                }

                if (typeof b.price_close === "number") priceSeries.update({ time: b.time, value: b.price_close });
                if (typeof b.cvd_usdt === "number") cvdSeries.update({ time: b.time, value: b.cvd_usdt });

                page.oldestTime = bars.length ? bars[0].time : null;

                // Â¶ÇÊûúÂ§Ñ‰∫é follow Ê®°ÂºèÔºåËÆ©ÂõæËá™Âä®Ë¥¥‰ΩèÊúÄÊñ∞
                if (isFollowing) {
                    programmaticScroll = true;
                    // Áî® requestAnimationFrame ÈÅøÂÖç setData/update ÂêéÁ´ãÂç≥ÊªöÂä®ÂØºËá¥ÊäñÂä®
                    requestAnimationFrame(() => {
                        priceChart.timeScale().scrollToRealTime();
                        programmaticScroll = false;
                    });
                }
            };

            ws.onerror = (err) => {
                console.error('WebSocket error:', err);
                statusEl.textContent = "error";
            };

            ws.onclose = () => {
                if (wsWant.key !== wantKey) return; // Already switched
                wsReconnectAttempts++;
                if (wsReconnectAttempts <= CONFIG.WS_MAX_RECONNECT_ATTEMPTS) {
                    statusEl.textContent = `reconnecting (${wsReconnectAttempts}/${CONFIG.WS_MAX_RECONNECT_ATTEMPTS})‚Ä¶`;
                    wsReconnectTimeout = setTimeout(
                        () => connectWs(exchange, symbol, market, tf),
                        CONFIG.WS_RECONNECT_DELAY
                    );
                } else {
                    statusEl.textContent = "disconnected";
                }
            };
        }

        // ==================== PERSISTENCE ====================
        function savePreferences() {
            const prefs = {
                exchange: exchangeSel.value,
                symbol: symbolSel.value,
                market: marketSel.value,
                tf: tfSel.value,
                tz: tzSel.value,
            };
            localStorage.setItem(CONFIG.STORAGE_KEY_PREFIX + 'prefs', JSON.stringify(prefs));
        }

        function loadPreferences() {
            const stored = localStorage.getItem(CONFIG.STORAGE_KEY_PREFIX + 'prefs');
            if (!stored) return;
            try {
                const prefs = JSON.parse(stored);
                if (prefs.exchange && EXCHANGE_CONFIG[prefs.exchange]) exchangeSel.value = prefs.exchange;
                updateMarketOptions();
                if (prefs.market && prefs.market !== marketSel.value) marketSel.value = prefs.market;
                if (prefs.symbol && prefs.symbol !== symbolSel.value) symbolSel.value = prefs.symbol;
                if (prefs.tf) tfSel.value = prefs.tf;
                if (prefs.tz) tzSel.value = prefs.tz;
            } catch (err) {
                console.warn('Failed to load preferences:', err);
            }
        }

        // ==================== RELOAD & LISTENERS ====================
        async function reload() {
            const e = exchangeSel.value, s = symbolSel.value, m = marketSel.value, tf = tfSel.value;
            const key = `${e}|${s}|${m}|${tf}`;
            if (page.lastKey !== key) {
                page.lastKey = key;
                page.bars = [];
                page.oldestTime = null;
                page.loadingMore = false;
                page.reachedStart = false;
            }
            savePreferences();
            updateTitle();
            await loadInitial(e, s, m, tf);
            connectWs(e, s, m, tf);
        }

        function updateTitle() {
            const e = exchangeSel.value.toUpperCase();
            const s = symbolSel.value;
            const m = marketSel.value.toUpperCase();
            const tf = tfSel.value;
            document.title = `${s} ${m} (${e}) ${tf}`;
        }

        exchangeSel.onchange = () => {
            updateMarketOptions();
            reload();
        };
        symbolSel.onchange = reload;
        marketSel.onchange = reload;
        tfSel.onchange = reload;
        tzSel.onchange = () => {
            currentTz = tzSel.value;
            savePreferences();
            applyTz(priceChart);
            applyTz(cvdChart);
        };

        // Initialize: load saved preferences, then reload
        loadPreferences();
        updateMarketOptions();
        updateTitle();
        reload();

        /* ---------- screenshot (ÊñπÊ°à BÔºöÂêàÊàê‰∏ÄÂº†) ---------- */
        function screenshotBoth() {
            const c1 = priceChart.takeScreenshot();
            const c2 = cvdChart.takeScreenshot();

            const w = Math.max(c1.width, c2.width);
            const h = c1.height + c2.height;

            const out = document.createElement("canvas");
            out.width = w;
            out.height = h;

            const ctx = out.getContext("2d");
            // ËÉåÊôØËâ≤ÔºåÈÅøÂÖçÈÄèÊòé
            ctx.fillStyle = "#111";
            ctx.fillRect(0, 0, w, h);

            ctx.drawImage(c1, 0, 0);
            ctx.drawImage(c2, 0, c1.height);

            const a = document.createElement("a");
            a.download = `cvd_${exchangeSel.value}_${symbolSel.value}_${marketSel.value}_${tfSel.value}.png`;
            a.href = out.toDataURL("image/png");
            a.click();
        }

        // ==================== KEYBOARD SHORTCUTS ====================
        document.addEventListener('keydown', (e) => {
            // Alt+E: focus on exchange selector
            if (e.altKey && e.key === 'e') {
                e.preventDefault();
                exchangeSel.focus();
            }
            // Alt+S: focus on symbol selector
            if (e.altKey && e.key === 's') {
                e.preventDefault();
                symbolSel.focus();
            }
            // Alt+T: focus on timeframe selector
            if (e.altKey && e.key === 't') {
                e.preventDefault();
                tfSel.focus();
            }
            // Alt+P: take screenshot
            if (e.altKey && e.key === 'p') {
                e.preventDefault();
                screenshotBoth();
            }
        });

        document.getElementById("shotAll").onclick = screenshotBoth;
    </script>
</body>

</html>