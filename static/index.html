<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CVD</title>

    <style>
        body {
            margin: 0;
            background: #111;
            color: #ddd;
            font-family: sans-serif
        }

        .bar {
            padding: 8px;
            display: flex;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid #222;
            flex-wrap: wrap
        }

        #wrap {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 46px)
        }

        #price {
            flex: 2
        }

        #cvd {
            flex: 1;
            border-top: 1px solid #333
        }

        select {
            background: #222;
            color: #ddd;
            border: 1px solid #444;
            padding: 4px 8px;
            border-radius: 6px
        }

        .pill {
            font-size: 12px;
            padding: 2px 8px;
            border: 1px solid #333;
            border-radius: 999px
        }
    </style>
</head>

<body>

    <div class="bar">
        <div class="pill">Source: local axum</div>

        Exchange:
        <select id="exchange">
            <option value="binance">Binance</option>
            <option value="coinbase">Coinbase</option>
        </select>

        Symbol:
        <select id="symbol">
            <option>BTC</option>
            <option>ETH</option>
            <option>SOL</option>
            <option>BNB</option>
            <option>AAVE</option>
        </select>

        Market:
        <select id="market">
            <option>spot</option>
            <option>usdm</option>
            <option>coinm</option>
        </select>

        TF:
        <select id="tf">
            <option>1m</option>
            <option>5m</option>
        </select>

        <div id="status" class="pill">loading…</div>
    </div>

    <div id="wrap">
        <div id="price"></div>
        <div id="cvd"></div>
    </div>

    <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>

    <script>

        const CONFIG = {
            HISTORY_PAGE_SIZE: 800,
            WINDOW_SIZE: 20000,
            EDGE_TRIGGER: 30,
            FETCH_COOLDOWN: 300
        }

        const exchangeSel = document.getElementById("exchange")
        const symbolSel = document.getElementById("symbol")
        const marketSel = document.getElementById("market")
        const tfSel = document.getElementById("tf")
        const statusEl = document.getElementById("status")

        function mkChart(el) {
            return LightweightCharts.createChart(el, {
                layout: { background: { color: "#111" }, textColor: "#ddd" },
                grid: { vertLines: { color: "#222" }, horzLines: { color: "#222" } },
                timeScale: {
                    borderColor: "#333",
                    timeVisible: true,      // ✅ 显示分钟
                    secondsVisible: false   // ✅ 不显示秒
                },
                rightPriceScale: { borderColor: "#333" }
            })
        }

        const priceChart = mkChart(document.getElementById("price"))
        const cvdChart = mkChart(document.getElementById("cvd"))

        const priceSeries = priceChart.addLineSeries({ color: "#f2c94c" })
        const cvdSeries = cvdChart.addLineSeries({ color: "#56ccf2" })

        let programmaticRangeChange = false
        let syncing = false
        let lastBeforeFetchAt = 0
        let lastAfterFetchAt = 0
        let ws = null

        function sync(a, b) {
            a.timeScale().subscribeVisibleLogicalRangeChange(r => {
                if (programmaticRangeChange) return
                if (!r || syncing) return
                syncing = true
                b.timeScale().setVisibleLogicalRange(r)
                syncing = false
            })
        }
        sync(priceChart, cvdChart)
        sync(cvdChart, priceChart)

        const page = {
            bars: [],
            oldestTime: null,
            newestTime: null,
            loadingOlder: false,
            loadingNewer: false,
            reachedStart: false,
            reachedEnd: false
        }

        function setBars(bars, keepRange = null) {
            programmaticRangeChange = true
            page.bars = bars
            page.oldestTime = bars[0]?.time ?? null
            page.newestTime = bars[bars.length - 1]?.time ?? null

            priceSeries.setData(bars.map(b => ({ time: b.time, value: b.price_close })))
            cvdSeries.setData(bars.map(b => ({ time: b.time, value: b.cvd_usdt })))

            if (keepRange) priceChart.timeScale().setVisibleLogicalRange(keepRange)

            requestAnimationFrame(() => programmaticRangeChange = false)
        }

        function trimToWindow(bars, oldRange) {
            if (bars.length <= CONFIG.WINDOW_SIZE) return { bars, newRange: oldRange }
            const start = bars.length - CONFIG.WINDOW_SIZE
            const sliced = bars.slice(start)
            let newRange = oldRange
            if (oldRange) newRange = { from: oldRange.from - start, to: oldRange.to - start }
            return { bars: sliced, newRange }
        }

        async function fetchHistory(limit, before = null, after = null) {
            const u = new URL("/history", location.origin)
            u.searchParams.set("exchange", exchangeSel.value)
            u.searchParams.set("symbol", symbolSel.value)
            u.searchParams.set("market", marketSel.value)
            u.searchParams.set("tf", tfSel.value)
            u.searchParams.set("limit", limit)
            if (before != null) u.searchParams.set("before", before)
            if (after != null) u.searchParams.set("after", after)
            const r = await fetch(u)
            return r.ok ? await r.json() : []
        }

        async function loadInitial() {
            statusEl.textContent = "loading…"
            page.reachedStart = false
            page.reachedEnd = false
            const bars = await fetchHistory(CONFIG.HISTORY_PAGE_SIZE)
            setBars(bars || [])
            statusEl.textContent = "live"
        }

        async function loadMoreBefore() {
            if (page.loadingOlder || page.reachedStart) return
            if (!page.oldestTime) return
            const now = Date.now()
            if (now - lastBeforeFetchAt < CONFIG.FETCH_COOLDOWN) return
            lastBeforeFetchAt = now

            page.loadingOlder = true
            const oldRange = priceChart.timeScale().getVisibleLogicalRange()

            try {
                const older = await fetchHistory(CONFIG.HISTORY_PAGE_SIZE, page.oldestTime, null)
                if (!older.length) { page.reachedStart = true; return }
                const merged = [...older.filter(b => b.time < page.oldestTime), ...page.bars]
                const trimmed = trimToWindow(merged, oldRange)
                setBars(trimmed.bars, trimmed.newRange)
            } finally { page.loadingOlder = false }
        }

        async function loadMoreAfter() {
            if (page.loadingNewer || page.reachedEnd) return
            if (!page.newestTime) return
            const now = Date.now()
            if (now - lastAfterFetchAt < CONFIG.FETCH_COOLDOWN) return
            lastAfterFetchAt = now

            page.loadingNewer = true
            const oldRange = priceChart.timeScale().getVisibleLogicalRange()

            try {
                const newer = await fetchHistory(CONFIG.HISTORY_PAGE_SIZE, null, page.newestTime)
                if (!newer.length) { page.reachedEnd = true; return }
                const merged = [...page.bars, ...newer.filter(b => b.time > page.newestTime)]
                const trimmed = trimToWindow(merged, oldRange)
                setBars(trimmed.bars, trimmed.newRange)
            } finally { page.loadingNewer = false }
        }

        priceChart.timeScale().subscribeVisibleLogicalRangeChange(r => {
            if (programmaticRangeChange) return
            if (!r || !page.bars.length) return

            if (r.from <= CONFIG.EDGE_TRIGGER) loadMoreBefore()

            const maxIndex = page.bars.length - 1
            const rightIndex = Math.min(r.to, maxIndex)
            const rightGap = maxIndex - rightIndex

            if (rightGap <= CONFIG.EDGE_TRIGGER) loadMoreAfter()
        })

        function connectWs() {
            if (ws) ws.close()
            const proto = location.protocol === "https:" ? "wss" : "ws"
            ws = new WebSocket(`${proto}://${location.host}/ws?exchange=${exchangeSel.value}&symbol=${symbolSel.value}&market=${marketSel.value}&tf=${tfSel.value}`)

            ws.onopen = () => statusEl.textContent = "live"

            ws.onmessage = ev => {
                const b = JSON.parse(ev.data)
                if (!b.time) return

                const last = page.bars[page.bars.length - 1]

                if (last && last.time === b.time) {
                    page.bars[page.bars.length - 1] = b
                } else if (!last || b.time > last.time) {
                    page.bars.push(b)
                }

                if (page.bars.length > CONFIG.WINDOW_SIZE) {
                    const r = priceChart.timeScale().getVisibleLogicalRange()
                    const trimmed = trimToWindow(page.bars, r)
                    setBars(trimmed.bars, trimmed.newRange)
                } else {
                    priceSeries.update({ time: b.time, value: b.price_close })
                    cvdSeries.update({ time: b.time, value: b.cvd_usdt })
                }

                page.newestTime = b.time
            }

            ws.onclose = () => setTimeout(connectWs, 3000)
        }

        function reload() {
            page.bars = []
            page.oldestTime = null
            page.newestTime = null
            lastAfterFetchAt = 0
            lastBeforeFetchAt = 0
            loadInitial()
            connectWs()
        }

        exchangeSel.onchange = reload
        symbolSel.onchange = reload
        marketSel.onchange = reload
        tfSel.onchange = reload

        reload()

    </script>
</body>

</html>